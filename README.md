<p>General<br>
  
1.  Find the most frequent integer in an array<br>
2.  Find pairs in an integer array whose sum is equal to 10 (bonus: do it in linear time)<br>
3.  Given 2 integer arrays, determine of the 2nd array is a rotated version of the 1st array
4.  Write fibbonaci iteratively and recursively (bonus: use dynamic programming)<br>
5.  Find the only element in an array that only occurs once.<br>
6.  Find the common elements of 2 int arrays<br>
7.  Implement binary search of a sorted array of integers<br>
8.  Implement binary search in a rotated array (ex. {5,6,7,8,1,2,3})<br>
9.  Use dynamic programming to find the first X prime numbers<br>
10. Write a function that prints out the binary form of an int<br>
11. Implement parseInt<br>
12. Implement squareroot function<br>
13. Implement an exponent function (bonus: now try in log(n) time)<br>
14. Write a multiply function that multiples 2 integers without using *<br>
15. HARD: Given a function rand5() that returns a random int between 0 and 5, implement rand7()<br>
16. HARD: Given a 2D array of 1s and 0s, count the number of “islands of 1s” (e.g. groups of connecting 1s)</p>

===============================

<p>Strings<br>
  
1.  Find the first non-repeated character in a String<br>
2.  Reverse a String iteratively and recursively<br>
3.  Determine if 2 Strings are anagrams<br>
4.  Check if String is a palindrome<br>
5.  Check if a String is composed of all unique characters<br>
6.  Determine if a String is an int or a double<br>
7.  HARD: Find the shortest palindrome in a String<br>
8.  HARD: Print all permutations of a String</p>

===============================

<p>Trees<br>
  
1.  Implement a BST with insert and delete functions<br>
2.  Print a tree using BFS and DFS<br>
3.  Write a function that determines if a tree is a BST<br>
4.  Find the smallest element in a BST<br>
5.  Find the 2nd largest number in a BST<br>
6.  Given a binary tree which is a sum tree (child nodes add to parent), <br>
7.  Find the distance between 2 nodes in a BST and a normal binary tree<br>
8.  Print the coordinates of every node in a binary tree, where root is 0,0<br>
9.  Print a tree by levels<br>
10. Given a binary tree which is a sum tree, write an algorithm to determine whether the tree is a valid sum tree<br>
11. Given a tree, verify that it contains a subtree.<br>
12. HARD: Construct a BST given the pre-order and in-order traversal Strings</p>

===============================

<p>Stacks, Queues, and Heaps<br>
  
1.  Implement a stack with push and pop functions<br>
2.  Implement a queue with queue and dequeue functions<br>
3.  Find the minimum element in a stack in O(1) time<br>
4.  Write a function that sorts a stack (bonus: sort the stack in place without extra memory)<br>
5.  Implement a binary min heap. Turn it into a binary max heap<br>
6.  HARD: Implement a queue using 2 stacks</p>

===============================

<p>Linked Lists<br>
  
1.  Implement a linked list (with insert and delete functions)<br>
2.  Find the Nth element in a linked list<br>
3.  Remove the Nth element of a linked list<br>
4.  Check if a linked list has cycles<br>
5.  Given a circular linked list, find the node at the beginning of the loop.<br>
6.  Check whether a link list is a palindrome<br>
7.  Reverse a linked list iteratively and recursively</p>

===============================

<p>Sorting<br>
  
1.  Implement bubble sort<br>
2.  Implement selection sort<br>
3.  Implement insertion sort<br>
4.  Implement merge sort<br>
5.  Implement quick sort</p>
